=head1 NAME

IO::FD - socket, listen, accept, read, write and more with file descriptors, not handles

=head1 SYNOPSIS

Create and bind a STREAM socket (server):

	use IO::FD
	use Socket ":all";

	die "Error creating socket"
		unless IO::FD::socket(my $listen_fd, AF_INET, SOCK_STREAM, 0);

	my ($err, @sockaddr)=addrinfo "0.0.0.0", 80, {
		family=>	AF_INET,
		socktype=>	SOCK_STREAM,
		flags=>		AI_NUMERICHOST|AI_PASSIVE
	};

	die "Error binding"
		unless FD::IO::bind($listen_fd, $sockaddr[0]{addr});	

	
	die "Error accepting" 
		unless IO::FD::accept(my $client_fd, $listen_fd);
	
	#read and write here
	

Create and connect a STREAM socket(client):
	
	use IO::FD;
	use Socket ":all";

	die "Error creating socket"
		unless IO::FD::socket(my $fd, AF_INET,SOCK_STREAM,0);

	my ($err,@sockaddr)=addrinfo "127.0.0.1", 80, {
		family=>	AF_INET,
		socktype=>	SOCK_STREAM,
		flags=>		AI_NUMERICHOST
	};

	die "Error connecting";
		unless FD::IO::connect($fd, $sockaddr[0]{addr});

	#read and write here

Open a file

	use IO::FD;
	use Fcntl;
	die "could not open file" 
		unless IO::FD::sysopen(my $fd, "path.txt", O_RDONLY);
	

Read/Write/Close an fd

	use IO::FD;

	my $fd; #From IO::FD::socket, IO::FD::accept IO::FD::sysopen, POSIX::open

	die "Error writing"
		unless IO::FD::syswrite $fd, "This is some data"; #Length and optional offset

	die "Error reading"
		unless IO::FD::sysread $fd, my $buffer, $length); 

	die "Error closing" 
		unless IO::FD::close $fd;


Advanced:

	fctrl...
	ioctl...


=head1 DESCRIPTION

IO::FD implements core Perl and system I/O operations such as C<socket>,
C<accept>, C<bind>, C<sysopen>, C<sysread>, C<syswrite> etc on B<file
descriptors> instead of Perl B<file handles>. 

It also implements non core functions such as C<dup>, C<mkstemp> which also
work on file descriptors.


These interfaces mostly resemble the core Perl implementations of similarly
named functions. 

For example:

	#Perl:
	sysopen(my $file_handle, ...);
	sysread($file_handle, ...);

	#IO::FD
	IO::FD::sysopen(my $file_descriptor, ...);
	IO::FD::sysread($file_descriptor, ...);

The full list of routines are listed in the API section, but include C<socket>,
C<accept>, C<bind>, C<sysopen>, C<sysread>, C<syswrite>.

This modules B<IS NOT> intended to be a drop in replacement for core IO
subroutines in existing code and does not export anything. If you want a 'drop
in replacement' please look at L<IO::FD::DWIM> which is part of the same
distribution.


This module can significantly lower memory usage per file descriptor and
decrease file/socket opening and socket accepting times.  Actual byte
throughput (read/write) is basically unchanged compared to the core Perl
sysread/syswrite.  Please see the PERFORMANCE section later in this document


Currently this module is focused on Unix/Linux systems, as this is the natural
habitat of a file descriptor.

=head1 LIMITATIONS

Perl does a lot of nice things when working with files. When using file
descriptors directly B<you will loose>:

	Buffering for file read/write performance (via print and <FH>)
	Automatic close when out of scope
	Close on exec
	Special variables not supported (ie '_' in stat)
	No 'readline' support  (ie <FH>)
	Not a subclass of IO::Handle, so no OO
	

TODO:
	Attempt to work with winsock?

=head1 MOTIVATION

Perl makes working with text files easy, thanks to B<file handles>.  Line
splitting, UTF-8, EOL processing etc. are awesome and make your life easier.

However the benefits of file handles in a network context or binary files are
not so clear cut. All the nice line ending and encoding support doesn't help
most of the time.

In addition, the OS kernel does a lot of buffering for networking already. Do we
really need to add more?

So if these features are not being fully utilised for binary/network
programming, the hypothesis is that opening and accepting operations would be
faster with file descriptors as less setup is required internally.

=head1 APIs

Each of the APIs mimic the Perl counterpart (if applicable) as much as
possible. Unless explicitly mentioned, they should operate like built in
routines. 


=head2 Socket Manipulation

=head3 socket

=head3 socketpair

=head3 bind

=head3 listen

=head3 accept

=head3 connect

=head3 getsockopt

=head3 setsockopt

Note: Implements the integer shorthand as per perldoc -f setsockopt

=head3 getpeername

=head3 getsockname


=head2 File Maniupulation

=head3 sysopen

=head3 sysopen4

Same as sysopen, but expects all four arguments

=head3 mktemp

=head3 mkstemp

=head3 sysseek


=head2 Pipes

=head3 pipe

=head3 syspipe

A alias of pipe.

=head2 Common

=head3 dup

=head3 dup2

=head3 close

=head3 recv

=head3 send

=head3 sysread

=head3 sysread3

Same as sysread, but expects only 3 of 4 arguments

=head3 sysread4

Same as sysread, but expects all four arguments

=head3 syswrite

=head3 syswrite2

Same as syswrite, but expect 2 of 4 arguments.

=head3 syswrite3

Same as syswrite, but expect 3 of 4 arguments.

=head3 syswrite4

Same as syswrite, but expect 4 of 4 arguments.

=head3 fcntl

=head3 sysfcntl

Alias to fcntl

=head3 stat

Likely differences to Perl stat for larger integer values

=head3 lstat

Likely differences to Perl lstat for larger integer values





=head2 Experimental

These haven't really been tested, documented or finished. They exist none the
less.  You will need to Look at the code for documentation at the moment. Their
behaviour and interface are LIKELY TO CHANGE without notice.

=head3 ioctl

Not complete

=head3 sysioctl

Alias to ioctl

=head3 clock_gettime_monotonic

=head3 select

=head3 poll

Constants for use with poll are available via  C<IO::FD:Constants>

=head3 kqueue

=head3 kevent

Constants for use with kevent are available via  C<IO::FD:Constants>

=head3 pack_kevent

=head3 sv_to_pointer

=head3 pointer_to_sv

=head3 SV
	
	IO::FD::SV($size)

Allocates a string SV with the given size preallocated. The current string
length is set to 0. For short string this is not the fastest way to allocate.
For 4k and above, it is much faster, and doesn't use extra memory in
compilation


=head3 readline

	#SLURP A FILE
	local $/=undef;
	my $slurp=IO::FD::readline;

		#or
	#SLURP ALL RECORDS
	local $/=\1234;
	my @records=IO::FD::readline;

A read line function is available, but is only operates in file slurp or
record slurp mode. As no buffering is used, It does not attempt to split
lines or read a line at a time like the normal Perl readline or  <>
operator

=head3 slurp

	my $data=IO::FD::slurp $path;

Open file at $path, read the contents into scalar and close the file.

=head3 spew 

	IO::FD::spew $path, $data;

Open a file at $path, write $data, close file


=head1 PERFORMANCE

Part of this distribution are benchmarking scripts. The following are typical
outputs from my Intel 2020 Macbook Pro.


=head2	Memory Usage

	Creating 2000 file handles/descriptors
	Start maxrss (kB): 4500

	Perl file handles
	Bytes: 905216, per handle: 452.608

	IO::FD
	Bytes: 4096, per fd: 2.048

	End maxrss (kB): 5692

=head2 Socket creation 

			     Rate perl_socket_INET iofd_socket_INET
	perl_socket_INET  81919/s               --             -56%
	iofd_socket_INET 185679/s             127%               --
			      Rate perl_socket_INET6 iofd_socket_INET6
	perl_socket_INET6  81498/s                --              -57%
	iofd_socket_INET6 189253/s              132%                --
			     Rate perl_socket_UNIX iofd_socket_UNIX
	perl_socket_UNIX 113778/s               --             -78%
	iofd_socket_UNIX 508970/s             347%               --

=head2 File open and close

			    Rate     file_handle file_desc_posix           io_fd
	file_handle      91897/s              --            -35%            -37%
	file_desc_posix 140549/s             53%              --             -4%
	io_fd           146161/s             59%              4%              --

=head2 Read Performance

	Read performance:
	Read (bytes): 1024 x 2^0
			     Rate file_desc_posix     file_handle           io_fd
	file_desc_posix 1803743/s              --             -5%             -5%
	file_handle     1889325/s              5%              --             -0%
	io_fd           1890461/s              5%              0%              --
	Read (bytes): 1024 x 2^1
			     Rate file_desc_posix           io_fd     file_handle
	file_desc_posix 1799026/s              --             -1%             -2%
	io_fd           1823610/s              1%              --             -1%
	file_handle     1837458/s              2%              1%              --
	Read (bytes): 1024 x 2^2
			     Rate file_desc_posix           io_fd     file_handle
	file_desc_posix 1731140/s              --             -1%             -1%
	io_fd           1747626/s              1%              --             -0%
	file_handle     1747627/s              1%              0%              --
	Read (bytes): 1024 x 2^3
			     Rate           io_fd file_desc_posix     file_handle
	io_fd           1458670/s              --             -1%             -3%
	file_desc_posix 1470359/s              1%              --             -2%
	file_handle     1499189/s              3%              2%              --
	Read (bytes): 1024 x 2^4
			     Rate file_desc_posix     file_handle           io_fd
	file_desc_posix 1146879/s              --             -3%             -6%
	file_handle     1180322/s              3%              --             -3%
	io_fd           1214700/s              6%              3%              --

=head2 Write Performance

	Write performance:
	Write (bytes): 1024 x 2^0
			     Rate file_desc_posix           io_fd     file_handle
	file_desc_posix 1978800/s              --             -7%            -12%
	io_fd           2117316/s              7%              --             -6%
	file_handle     2244774/s             13%              6%              --
	Write (bytes): 1024 x 2^1
			     Rate file_desc_posix           io_fd     file_handle
	file_desc_posix 2007408/s              --             -6%             -9%
	io_fd           2143700/s              7%              --             -3%
	file_handle     2205537/s             10%              3%              --
	Write (bytes): 1024 x 2^2
			     Rate file_desc_posix           io_fd     file_handle
	file_desc_posix 1978800/s              --             -7%            -12%
	io_fd           2123851/s              7%              --             -5%
	file_handle     2244774/s             13%              6%              --
	Write (bytes): 1024 x 2^3
			     Rate file_desc_posix           io_fd     file_handle
	file_desc_posix 1960478/s              --             -7%             -9%
	io_fd           2117316/s              8%              --             -2%
	file_handle     2163924/s             10%              2%              --
	Write (bytes): 1024 x 2^4
			     Rate file_desc_posix           io_fd     file_handle
	file_desc_posix 1997468/s              --             -5%             -8%
	io_fd           2104367/s              5%              --             -3%
	file_handle     2163924/s              8%              3%              --

=head2 Accepting sockets

	TODO



=head1 SEE ALSO

The L<POSIX> module provides an C<open>, C<close>, C<read> and C<write>
routines which return/work with file descriptors. If you are only concerned
with working with files, this is a better option as it is a core module, and
will give you the purported benefits of this module.  However it does not
provide any networking/socket support.

Perl's built in C<syscall> routine could implement most of this module. However
macos no longer has a syscall interface. That makes C<syscall> a non starter
for me.

If you are needing an event loop L<IO::AIO> might also be of use.


=head1 AUTHOR


Ruben Westerberg, E<lt>drclaw@mac.comE<gt>

=head1 REPOSITORTY and BUGS

Please report any bugs via git hub: L<http://github.com/drclaw1394/perl-io-fd>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2022 by Ruben Westerberg

This library is free software; you can redistribute it
and/or modify it under the same terms as Perl or the MIT
license.

=head1 DISCLAIMER OF WARRANTIES

THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS
OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE.
=cut
