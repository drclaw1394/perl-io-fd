=head1 NAME

IO::FD - poll, socket, accept, read, write and more with file descriptors, not handles

=head1 SYNOPSIS

Create and bind a STREAM socket (server):

	use IO::FD
	use Socket ":all";

	die "Error creating socket"
		unless IO::FD::socket(my $listen_fd, AF_INET,SOCK_STREAM,0);

	my ($err, @sockaddr)=addrinfo "0.0.0.0", 80, {
		family=>	AF_INET,
		socktype=>	SOCK_STREAM,
		flags=>		AI_NUMERICHOST|AI_PASSIVE
	};

	die "Error binding"
		unless FD::IO::bind($listen_fd,$sockaddr[0]{addr});	

	
	die "Error accepting" 
		unless IO::FD::accept(my $client_fd, $listen_fd);
	
	#read and write here
	

Create and connect a STREAM socket(client):
	
	use IO::FD;
	use Socket ":all";

	die "Error creating socket"
		unless IO::FD::socket(my $fd, AF_INET,SOCK_STREAM,0);

	my ($err,@sockaddr)=addrinfo "127.0.0.1", 80, {
		family=>	AF_INET,
		socktype=>	SOCK_STREAM,
		flags=>		AI_NUMERICHOST
	};

	die "Error connecting";
		unless FD::IO::connect($fd, $sockaddr[0]{addr});

	#read and write here

Open a file

	use IO::FD;
	use Fcntl;
	die "could not open file" 
		unless IO::FD::sysopen(my $fd, "path.txt", O_RDONLY);
	

Read/Write/Close an fd

	use IO::FD;

	my $fd; #From IO::FD::socket, IO::FD::accept IO::FD::sysopen, POSIX::open

	die "Error writing"
		unless IO::FD::syswrite $fd, "This is some data"; #Length and optional offset

	die "Error reading"
		unless IO::FD::sysread $fd, my $buffer, $length); 

	die "Error closing" 
		unless IO::FD::close $fd;


Advanced:

	fctrl...
	ioctl...


=head1 DESCRIPTION

IO::FD implements core perl and system I/O operations such as C<socket>,
C<accept>, C<bind>, C<sysopen>, C<sysread>, C<syswrite> etc on B<file
descriptors> instead of perl B<file handles>. 

It also implements non core functions such as C<poll>, C<dup>, supplimenting
the L<POSIX> module.

These interfaces mostly resemble the core perl implementations of similary
named functions. 

For example:

	#Perl:
	sysopen(my $file_handle, ...);
	sysread($file_handle, ...);

	#IO::FD
	IO::FD::sysopen(my $file_descriptor, ...);
	IO::FD::sysread($file_descriptor, ...);

The full list of routines are listed in the API section, but include C<socket>,
C<accept>, C<bind>, C<sysopen>, C<sysread>, C<syswrite>.

This modules B<IS NOT> intended to be a drop in replacement for core IO
subrotines in existing code and does not export anything. If you want a 'drop
in replacement' please look at L<IO::FD::DWIM> which is part of the same
distribution.


This module can significantly lower memory usage per file descriptor and
decrease file/socket opening and socket accepting times.  Acautal byte
throughput (read/write) is basically unchanged compared to the core perl
sysread/syswrite.  Please see the PERFORMANCE section later in this document


Currently focused on unix type systems, as this is the natural habitat of a
file descriptor.

=head1 LIMITATIONS

Perl does a lot of nice things when working with files, which when using file
descriptors directly you will B<loose>:

	Buffering for file read/write performance (via print and <FH>)
	Automatic close when out of scope
	Close on exec
	Special variables not supported (ie '_' in stat)
	No 'readline' support  (ie <FH>)
	
If you don't what these mean, it might be best to learn about how it will
impact your program before using this module.

The other main limitation is this module assumes you have file descriptors to
work with on your system.

TODO:
	Attempt to work with winsock?
	Additional fd functions (send fds , sendfile...)

=head1 MOTIVATION

Perl makes working with text files pretty easy, thanks to the use of B<file
handles>. Line splitting, UTF-8, EOL processing etc. are awesome and make your
life easier.

However the benefits of file handles in a network context or binary files are
not so clear cut. All the nice line ending and encoding support doesn't help
most of the time.

In addation, the OS kernel does alot of buffering for networking already. Do we
readlly need to add more?

So if these features are not being fully utilised for binary/network
programing, the hypothosis was that opening and accepting operations would be
faster with file descriptors as less setup is required internally.

=head1 APIs

Each of the APIs mimic the perl counterpart as much as possible. Unless
explicitly mentioned, they should operate like built in routines. 


=head2 Socket Manipulation

=head3 socket

=head3 socketpair

=head3 bind

=head3 listen

=head3 accept

=head3 connect

=head3 getsockopt

=head3 setsockopt

Note: Implements the integer shorthand as per perldoc -f setsockopt

=head3 getpeername

=head3 getsockname


=head2 File Maniupulation

=head3 sysopen

=head3 sysopen4

Same as sysopen, but expects all four arguments

=head3 mktemp

=head3 mkstemp

=head3 sysseek

=head2 Pipes

=head3 pipe

=head3 syspipe

A alias of pipe.

=head2 Common

=head3 dup

=head3 dup2

=head3 close

=head3 recv

=head3 send

=head3 sysread

=head3 sysread3

Same as sysread, but expects only 3 of 4 arguments

=head3 sysread4

Same as sysread, but expects all four arguments

=head3 syswrite

=head3 syswrite2

Same as syswrite, but expect 2 of 4 arguments.

=head3 syswrite3

Same as syswrite, but expect 3 of 4 arguments.

=head3 syswrite4

Same as syswrite, but expect 4 of 4 arguments.

=head3 fcntl

=head3 sysfcntl

Alias to fcntl

=head3 stat

Likely differences to perl stat for larger integer values

=head3 lstat

Likely differences to perl lstat for larger integer values

=head3 ioctl

not complete

=head3 sysioctl

Alias to ioctl




=head2 Experimental

These haven't been tested, documented or finished. They exist none the less.
You will need to Look at the code for documenation at the moment

=head3 clock_gettime_monotonic

=head3 select

=head3 poll

=head3 kqueue

=head3 kevent

=head3 pack_kevent

=head3 sv_to_pointer

=head3 pointer_to_sv

=head3 SV
	
	IO::FD::SV($size)

Allocates a string SV with the given size preallocated. The current string
lenth is set to 0. For short string this is not the fastest way to allocate.
For 4k and above, it is much faster, and doesn't use extra memory in
compilation






=head2 Extended API

=head3 readline

	#SLURP A FILE
	local $/=undef;
	my $slurp=IO::FD::readline;

		#or
	#SLURP ALL RECORDS
	local $/=\1234;
	my @records=IO::FD::readline;

A read line function is available, but is only operates in file slurp or
record slurp mode. As no buffering is used, It does not attempt to split
lines or read a line at a time like the normal perl readline or  <>
operator

=head3 slurp

	my $data=IO::FD::slurp $path;

Open file at $path, read the contents into scalar and close the file.

=head3 spew 

	IO::FD::spew $path, $data;

Open a file at $path, write $data, close file


=head1 PERFORMANCE

Part of this distribution are benchmarking scripts. The following are typical
outputs from my Intel 2020 MacbookPro.

=over

=item	Memory Usage

	Creating 2000 file handles/descriptors
	Start maxrss (kB): 4500

	Perl file handles
	Bytes: 905216, per handle: 452.608

	IO::FD
	Bytes: 4096, per fd: 2.048

	End maxrss (kB): 5692

=item Socket creation 

			     Rate perl_socket_INET iofd_socket_INET
	perl_socket_INET  81919/s               --             -56%
	iofd_socket_INET 185679/s             127%               --
			      Rate perl_socket_INET6 iofd_socket_INET6
	perl_socket_INET6  81498/s                --              -57%
	iofd_socket_INET6 189253/s              132%                --
			     Rate perl_socket_UNIX iofd_socket_UNIX
	perl_socket_UNIX 113778/s               --             -78%
	iofd_socket_UNIX 508970/s             347%               --

=item File open and close

			    Rate     file_handle file_desc_posix           io_fd
	file_handle      91897/s              --            -35%            -37%
	file_desc_posix 140549/s             53%              --             -4%
	io_fd           146161/s             59%              4%              --

=item Read Performance

	Read performance:
	Read (bytes): 1024 x 2^0
			     Rate file_desc_posix     file_handle           io_fd
	file_desc_posix 1803743/s              --             -5%             -5%
	file_handle     1889325/s              5%              --             -0%
	io_fd           1890461/s              5%              0%              --
	Read (bytes): 1024 x 2^1
			     Rate file_desc_posix           io_fd     file_handle
	file_desc_posix 1799026/s              --             -1%             -2%
	io_fd           1823610/s              1%              --             -1%
	file_handle     1837458/s              2%              1%              --
	Read (bytes): 1024 x 2^2
			     Rate file_desc_posix           io_fd     file_handle
	file_desc_posix 1731140/s              --             -1%             -1%
	io_fd           1747626/s              1%              --             -0%
	file_handle     1747627/s              1%              0%              --
	Read (bytes): 1024 x 2^3
			     Rate           io_fd file_desc_posix     file_handle
	io_fd           1458670/s              --             -1%             -3%
	file_desc_posix 1470359/s              1%              --             -2%
	file_handle     1499189/s              3%              2%              --
	Read (bytes): 1024 x 2^4
			     Rate file_desc_posix     file_handle           io_fd
	file_desc_posix 1146879/s              --             -3%             -6%
	file_handle     1180322/s              3%              --             -3%
	io_fd           1214700/s              6%              3%              --

=item Write Performance

	Write performance:
	Write (bytes): 1024 x 2^0
			     Rate file_desc_posix           io_fd     file_handle
	file_desc_posix 1978800/s              --             -7%            -12%
	io_fd           2117316/s              7%              --             -6%
	file_handle     2244774/s             13%              6%              --
	Write (bytes): 1024 x 2^1
			     Rate file_desc_posix           io_fd     file_handle
	file_desc_posix 2007408/s              --             -6%             -9%
	io_fd           2143700/s              7%              --             -3%
	file_handle     2205537/s             10%              3%              --
	Write (bytes): 1024 x 2^2
			     Rate file_desc_posix           io_fd     file_handle
	file_desc_posix 1978800/s              --             -7%            -12%
	io_fd           2123851/s              7%              --             -5%
	file_handle     2244774/s             13%              6%              --
	Write (bytes): 1024 x 2^3
			     Rate file_desc_posix           io_fd     file_handle
	file_desc_posix 1960478/s              --             -7%             -9%
	io_fd           2117316/s              8%              --             -2%
	file_handle     2163924/s             10%              2%              --
	Write (bytes): 1024 x 2^4
			     Rate file_desc_posix           io_fd     file_handle
	file_desc_posix 1997468/s              --             -5%             -8%
	io_fd           2104367/s              5%              --             -3%
	file_handle     2163924/s              8%              3%              --

=item Accepting sockets

	TODO


=back

=head2 Read throughput

=head2 Write throughput

=head2 Open and close a file

=head2 Create and close a socket

=head2 Accept and close socket

=head2 Echo server connection rate

=head1 SEE ALSO

The L<POSIX> module provides an C<open>, C<close>, C<read> and C<write>
routines which return/work with file descriptors. If you are only concerned
with working with files, this is a better option as it is a core module, and
will give you the purported benefits of this module.  However it does not
provide any networking/socket support.

Perl's built in C<syscall> routine could implement most of this module. However
macos no longer has a syscall interface. That makes C<syscall> a non starter
for me.

If you are needing an event loop L<IO::AIO> might also be of use.


=head1 AUTHOR


=head1 REPOSITORTY and BUGS

Please report any bugs via git hub: L<http://github.com/drclaw1394/perl-io-fd>

=head1 LICENSE

MIT license, or Perl license. Which ever your prefer
